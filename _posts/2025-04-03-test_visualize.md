---
layout: post
title:  "Grafana, InfluxDB 을 사용한 성능테스트 시각화"
---

저번에는 k6를 사용해서 성능 테스트를 했었다.

그런데 테스트 결과가 cli에 나오다 보니 별로 보기 좋지 않았고, 테스트 진행 상황을 실시간으로 볼 수 없었다. 그래서 이번에는 InfluxDB에 k6 테스트 데이터를 저장하고, Grafana를 통해서 시각화했다.

어차피 연동 과정은 도커 컴포즈 파일을 실행하고 data-source만 정해주면 알아서 되니까 이번 글은 기술들을 사용하면서 궁금했던 점들 위주로 작성하고자 한다. 

### 왜 InfluxDB를 쓰나?

influxDB는 시계열 데이터베이스라서 다른 종류의 데이터베이스들(rdb, nosql 등)보다 읽기, 쓰기가 빠르다.

### 시계열 데이터베이스의 장점

1. 높은 쓰기 성능 & 빠른 조회
    
    ✅ **쓰기 최적화**
    
    - 성능 테스트 중에는 초당 수천~수만 개의 데이터 포인트가 생성됨.
    - 일반적인 관계형 DB(MySQL, PostgreSQL)에서는 `INSERT` 성능이 한계에 부딪힘.
    - InfluxDB 같은 TSDB는 **append-only(추가 전용) 구조**로 설계되어 **고속 데이터 쓰기**가 가능함.
    
    ✅ **빠른 시간 기반 조회**
    
    - "지난 10분 동안의 평균 응답 시간" 같은 쿼리가 많음.
    - TSDB는 **시간 필터링에 최적화**되어 있어 쿼리가 빠름.
2. 자동 데이터 압축 & 보존 정책
    
    ✅ **데이터 압축 (Storage Optimization)**
    
    - InfluxDB는 오래된 데이터를 자동으로 **롤업(요약)**해서 저장 가능.
    - 예를 들어, **1초 단위 데이터를 1시간 단위 평균으로 자동 변환**해 저장하는 기능 제공.
    - 스토리지 절약 & 장기 분석에 유리함.
    
    ✅ **Retention Policy (보존 정책)**
    
    - "최근 7일간의 원본 데이터만 저장하고, 이후에는 요약 데이터만 남긴다" 같은 설정 가능.
    - 관계형 DB에서는 이런 작업을 직접 구현해야 하지만, TSDB에서는 **자동 처리**됨.
3. 태그 기반 데이터 모델링 (빠른 인덱싱)
    
    ✅ **태그(tag)를 활용한 빠른 검색**
    
    - TSDB는 `tag` 기반으로 데이터를 저장해, **메타데이터 필터링이 빠름**.
    - 예를 들어, 특정 서버의 응답 시간만 조회할 때 속도가 훨씬 빠름.

### 시계열 데이터베이스의 단점

1. **복잡한 쿼리(Join, 관계형 데이터 처리)에 약함**
    
    ✅ **문제점:**
    
    - TSDB는 일반적으로 `JOIN`을 지원하지 않거나, 매우 비효율적으로 처리됨.
    - `SQL`처럼 복잡한 관계형 데이터 모델을 다루기 어렵다.
2. 데이터 삭제 및 수정이 어려움 (Immutable 데이터 구조)
    
    ✅ **문제점:**
    
    - TSDB는 **append-only 구조**로 설계됨.
    - 즉, 한 번 기록된 데이터는 **수정/삭제가 어렵거나 비효율적임**.
3. 저장 공간 문제 (압축은 되지만, 데이터 양이 많으면 부담됨)
    
    ✅ **문제점:**
    
    - TSDB는 **고속 쓰기**를 위해 데이터 중복을 허용하는 구조임.
    - 따라서, 대량의 데이터를 기록할 경우 **스토리지 사용량이 커짐**.
    - 일반적인 RDBMS보다 많은 공간을 사용할 수도 있음.
4. 고가용성(HA) 및 복제 기능이 약함
    
    ✅ **문제점:**
    
    - MySQL, PostgreSQL 등 RDBMS는 **Replication(복제), Clustering(클러스터링) 기능이 강력**하지만,
        
        TSDB는 **일반적인 데이터베이스처럼 복제/클러스터링이 쉽지 않음**.
        
5. 데이터 조회(읽기) 성능이 일정 조건에서 낮아질 수 있음
    
    ✅ **문제점:**
    
    - TSDB는 시간 기반 데이터를 조회하는 데 최적화되어 있지만,
        
        특정 조건에서는 **일반적인 RDBMS보다 조회 속도가 떨어질 수 있음**.
        
        - 예: **고도로 필터링된 쿼리** (특정 사용자, 특정 이벤트 등)
        - 예: **대량 데이터 스캔**

![image](https://github.com/user-attachments/assets/a7cd9577-324f-4063-8545-edffec14482c)


### 많은 시계열 데이터베이스들 중에서 왜 InfluxDB를 쓰는가?

- **빠른 데이터 쓰기/읽기 성능** (TSM 엔진 최적화)
- **SQL 스타일의 InfluxQL & Flux 지원** (쉽고 강력한 쿼리)
- **자동 데이터 압축 & 보존 정책** (저장 공간 효율성 높음)
- **실시간 데이터 분석 가능** (Kapacitor 연동)
- **Grafana와 완벽한 시각화 지원**

→ 성능 테스트, 로그 모니터링, IoT 데이터 수집 등에 가장 적합한 TSDB 중 하나임

### 어떻게 다른 시계열 데이터베이스보다 InfluxDB가 읽기,쓰기가 더 빠른가?

1. **TSM (Time-Structured Merge Tree) 저장 엔진 → 쓰기 성능 최적화**
    
    ✅ **InfluxDB는 일반적인 B-Tree나 LSM-Tree가 아니라, "TSM 엔진"을 사용**
    
    - B-Tree 기반 RDBMS (MySQL, PostgreSQL) → 디스크 탐색이 많아서 시계열 데이터 쓰기에 비효율적
    - LSM-Tree 기반 TSDB (Cassandra, OpenTSDB) → 데이터 삽입 속도는 빠르지만 압축 효율이 낮음
    - **TSM 엔진(InfluxDB)** → 쓰기 전용 설계 + 데이터 압축 최적화
    
    ✅ **TSM 엔진의 원리**
    
    - **쓰기 데이터는 메모리(WAL: Write-Ahead Log)에서 먼저 처리됨**
    - 일정 시간이 지나면 **배치(batch)로 디스크에 기록** → 디스크 I/O 감소
    - **데이터를 시간순으로 정렬하여 저장** → 검색 시 빠름

1. **TSI (Time Series Index) → 빠른 조회 성능**
    
    ✅ **인덱스 구조 최적화 → 기존 B-Tree보다 빠름**
    
    - 기존 RDBMS는 **B-Tree 인덱스**를 사용 → 업데이트 비용이 큼
    - InfluxDB는 **TSI(Time Series Index)** 사용 → **읽기 성능 극대화**
    - 🔥 **고유한 데이터 포인트 수가 많아질수록 TSI가 더 효율적**
    
    ✅ **TSI 동작 방식**
    
    - **Tag 기반 인덱싱 → 필요한 데이터만 빠르게 검색 가능**
    - 데이터가 **시간순으로 정렬**되어 있어서 조회 속도가 빠름
    - 메모리에 인덱스를 캐싱하여 **디스크 I/O를 최소화**
2. **고효율 데이터 압축 (Double Delta + XOR Encoding)**
    
    ✅ **데이터를 효율적으로 압축하여 디스크 사용량 최소화**
    
    - 일반적으로 **시계열 데이터는 값의 변화가 작음** → 이 특성을 활용
    - **Double Delta Encoding**: 이전 값과의 차이만 저장 → 스토리지 절약
    - **XOR Encoding**: 64비트 숫자를 XOR 연산으로 압축 → 공간 효율 극대화
3. **Continuous Query & Retention Policy → 자동 데이터 요약 & 보존 최적화**
    
    ✅ **오래된 데이터 자동 삭제 & 요약 가능 → 디스크 사용량 최소화**
    
    - `Retention Policy`를 설정하면, **지정된 기간이 지난 데이터를 자동 삭제**
    - `Continuous Query(CQ)`를 설정하면, **자동으로 데이터 요약(aggregation)**
        - 예: 초 단위 데이터를 1시간 단위 평균값으로 요약
4. **WAL (Write-Ahead Log) → 안정적인 데이터 쓰기 처리**
    
    ✅ **메모리에 먼저 기록하고, 일정 시간 후 디스크에 저장 → 빠르고 안정적**
    
    - `Write-Ahead Log(WAL)`를 사용하여 **데이터 손실 방지 & 빠른 쓰기 성능 보장**
    - WAL을 활용하면, **갑작스러운 서버 장애에도 데이터 유실이 없음**

### 도커 컴포즈 파일

```yaml
version: "3.7"

services:
  influxdb:
    image: bitnami/influxdb:1.8.5
    container_name: influxdb
    ports:
      - "8086:8086"
      - "8085:8088"
    environment:
      - INFLUXDB_ADMIN_USER_PASSWORD=bitnami123
      - INFLUXDB_ADMIN_USER_TOKEN=admintoken123
      - INFLUXDB_HTTP_AUTH_ENABLED=false
      - INFLUXDB_DB=myk6db
  granafa:
    image: bitnami/grafana:latest
    ports:
      - "3000:3000"
```
